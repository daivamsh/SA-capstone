# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14zfvX7d5WdulkGnW097QsPlneS1hvQa7
"""

import pandas as pd
import numpy as np

pip install pathway

# Replace the path with your actual CSV file location
df = pd.read_csv('/content/dataset.csv')

# Check for missing values
print(df.isnull().sum())
# Drop or impute missing values as appropriate
df = df.dropna()

# Map traffic condition to numeric
traffic_map = {'low': 0, 'average': 1, 'high': 2}
df['TrafficLevel'] = df['TrafficConditionNearby'].map(traffic_map)

# Map vehicle type to weights
vehicle_weight = {'car': 1.0, 'bike': 0.5, 'truck': 2.0, 'cycle': 0.7}
df['VehicleTypeWeight'] = df['VehicleType'].map(vehicle_weight)

# Convert special day to integer (if not already)
df['IsSpecialDay'] = df['IsSpecialDay'].astype(int)

df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],format='%d-%m-%Y %H:%M:%S')
df = df.sort_values(['SystemCodeNumber', 'Timestamp'])

df['OccupancyRate'] = df['Occupancy'] / df['Capacity']

df['QueueLengthNorm'] = df['QueueLength'] / df['QueueLength'].max()

"""BASELINE LINEAR MODEL

"""

BASE_PRICE = 10
alpha = 2.0  # Tuning parameter

def baseline_linear_pricing(df, alpha=alpha, base_price=BASE_PRICE):
    df = df.copy()
    df['Price_Baseline'] = base_price
    for lot in df['SystemCodeNumber'].unique():
        lot_idx = df['SystemCodeNumber'] == lot
        lot_df = df.loc[lot_idx].sort_values('Timestamp')
        prices = [base_price]
        for occ_rate in lot_df['OccupancyRate'].iloc[1:]:
            new_price = prices[-1] + alpha * occ_rate
            prices.append(new_price)
        df.loc[lot_idx, 'Price_Baseline'] = prices
    return df

df = baseline_linear_pricing(df)

"""DEMAND BASED MODEL"""

# Define coefficients (tune as needed)
alpha_d, beta, gamma, delta, epsilon, lambd = 1.0, 0.5, 0.3, 0.7, 0.2, 0.5

df['Demand'] = (
    alpha_d * df['OccupancyRate'] +
    beta * df['QueueLength'] -
    gamma * df['TrafficLevel'] +
    delta * df['IsSpecialDay'] +
    epsilon * df['VehicleTypeWeight']
)

# Normalize demand for each lot
def normalize(series):
    return (series - series.min()) / (series.max() - series.min() + 1e-5)

df['NormalizedDemand'] = df.groupby('SystemCodeNumber')['Demand'].transform(normalize)

# Calculate price, bounded between 0.5x and 2x base price
def demand_based_price(row):
    price = BASE_PRICE * (1 + lambd * row['NormalizedDemand'])
    return min(max(price, BASE_PRICE * 0.5), BASE_PRICE * 2.0)

df['Price_Demand'] = df.apply(demand_based_price, axis=1)

"""COMPETITIVE PRICING MODEL"""

from scipy.spatial.distance import cdist

# Get unique lot locations
lots = df[['SystemCodeNumber', 'Latitude', 'Longitude']].drop_duplicates().reset_index(drop=True)

# Compute distance matrix (in degrees, for simplicity)
coords = lots[['Latitude', 'Longitude']].values
dist_matrix = cdist(coords, coords, metric='euclidean')

# Define a function to get nearby lots (within 0.01 degrees, ~1km)
def get_nearby_lots(lot_idx, radius=0.01):
    return np.where(dist_matrix[lot_idx] < radius)[0]

# Apply competitive logic
def competitive_pricing(df, lots, dist_matrix, base_price=BASE_PRICE):
    df = df.copy()
    df['Price_Competitive'] = df['Price_Demand']
    lot_indices = {lot: i for i, lot in enumerate(lots['SystemCodeNumber'])}
    for lot in lots['SystemCodeNumber']:
        lot_idx = lot_indices[lot]
        nearby_idxs = get_nearby_lots(lot_idx)
        nearby_lots = lots.iloc[nearby_idxs]['SystemCodeNumber'].tolist()
        lot_df = df[df['SystemCodeNumber'] == lot].sort_values('Timestamp')
        for idx, row in lot_df.iterrows():
            # Get competitor prices at the same timestamp
            ts = row['Timestamp']
            competitors = df[(df['Timestamp'] == ts) & (df['SystemCodeNumber'].isin(nearby_lots))]
            competitor_prices = competitors['Price_Demand']
            my_price = row['Price_Demand']
            if row['Occupancy'] >= row['Capacity']:
                # If full and competitors are cheaper, reduce price
                if (competitor_prices < my_price).any():
                    df.at[idx, 'Price_Competitive'] = my_price * 0.95
            elif (competitor_prices > my_price).all():
                # If all competitors are more expensive, can increase price
                df.at[idx, 'Price_Competitive'] = min(my_price * 1.05, base_price * 2.0)
    return df

df = competitive_pricing(df, lots, dist_matrix)

"""REALTIME STREAMING WITH PATHWAY"""

import pathway as pw

# Define schema
class ParkingLotSchema(pw.Schema):
    SystemCodeNumber: str
    Capacity: int
    Occupancy: int
    QueueLength: int
    VehicleType: str
    Latitude: float
    Longitude: float
    TrafficConditionNearby: str
    IsSpecialDay: int
    LastUpdatedDate: str
    LastUpdatedTime: str

# Ingest data (simulate streaming from CSV)
parking_stream = pw.io.csv.read('/content/dataset.csv', schema=ParkingLotSchema)

@pw.udf
def compute_features(occupancy: int, capacity: int, traffic_condition: str, vehicle_type: str):
    occupancy_rate = occupancy / capacity
    traffic_map = {'low': 0, 'average': 1, 'high': 2}
    traffic_level = traffic_map.get(traffic_condition, 1)
    vehicle_weight = {'car': 1.0, 'bike': 0.5, 'truck': 2.0, 'cycle': 0.7}
    vehicle_type_weight = vehicle_weight.get(vehicle_type, 1.0)
    return occupancy_rate, traffic_level, vehicle_type_weight

features = pw.apply(compute_features, parking_stream.Occupancy, parking_stream.Capacity, parking_stream.TrafficConditionNearby, parking_stream.VehicleType)

parking_stream = parking_stream.with_columns(
    OccupancyRate=features[0],
    TrafficLevel=features[1],
    VehicleTypeWeight=features[2]
)

# Pricing logic as UDF
@pw.udf
def demand_price(occupancy_rate: float, queue_length: int, traffic_level: int, is_special_day: int, vehicle_type_weight: float, base_price=10, lambd=0.5):
    demand = (
        1.0 * occupancy_rate +
        0.5 * queue_length -
        0.3 * traffic_level +
        0.7 * is_special_day +
        0.2 * vehicle_type_weight
    )
    # For demonstration, normalization and bounding can be added as in pandas code
    price = base_price * (1 + lambd * demand)
    return min(max(price, base_price * 0.5), base_price * 2.0)

parking_stream = parking_stream.with_columns(
    Price_Demand=pw.apply(demand_price, parking_stream.OccupancyRate, parking_stream.QueueLength, parking_stream.TrafficLevel, parking_stream.IsSpecialDay, parking_stream.VehicleTypeWeight)
)

# Output streaming results
pw.io.jsonlines.write(parking_stream, 'output_stream.jsonl')

# Start Pathway computation
pw.run()

